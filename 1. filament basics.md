# Filament Basics

Filament is a real-time physically based rendering engine. Physically based rendering (PBR) is a computer graphics approach that seeks to render images in a way that models the flow of light in the real world. Essentially it means, Filament rendering is highly performant and focuses on keeping the renderings look as natural as possible.

## Filament Rendering components

### Engine
As defined in filaments code, 
> An Engine instance main function is to keep track of all resources created by the user and manage the rendering thread as well as the hardware renderer. 

In my words, Engine manages the whole View, it's components(Scene, Renderer, Objects, Lighting, etc), handles asset loading and resource usage.

### Renderer
> A Renderer instance represents an operating system's window. Typically, applications create a Renderer per window. The Renderer generates drawing commands for the render thread and manages frame latency.
A Renderer generates drawing commands from a View, itself containing a Scene description. 

It draws the Scene on the OS's window as per the view

### View
> Encompasses all the state needed for rendering a Scene. View instances are heavy objects that internally cache a lot of data needed for rendering. 
 
The View contains everything required for rendering a scene, which includes, the Scene itself, Camera, ViewPort and some other rendering parameters.

### Scene
> A Scene is a flat container of RenderableManager and LightManager components.
 
It manages the Lighting and Objects.

### Camera
> Camera represents the eye through which the scene is viewed.A Camera has a position and orientation and controls the projection and exposure parameters. 

Camera represents the perception through which the scene is viewed.

### Skybox
> When added to a Scene, the Skybox fills all untouched pixels.
> Currently only Texture based sky boxes are supported. current version 1.14.2
Scene background


## Android Kotlin Code Snippets
Activity onCreate

```
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    engine = Engine.create()
    renderer = engine.createRenderer()
    scene = engine.createScene()
    view = engine.createView()
    camera = engine.createCamera(engine.entityManager.create())
}
```

Activity onDestory
```
override fun onDestroy() {
    super.onDestroy()

    // Cleanup all resources
    engine.destroyRenderer(renderer)
    engine.destroyView(view)
    engine.destroyScene(scene)
    engine.destroyCameraComponent(camera.entity)
    
    // Engine.destroyEntity() destroys Filament related resources only
    // (components), not the entity itself

    // Destroying the engine will free up any resource you may have forgotten
    // to destroy, but it's recommended to do the cleanup properly
    engine.destroy()
}
```

> Now take a look into the [HelloTriangle Android Sample]((https://github.com/google/filament/blob/ca3b84197441e351ef490d61cbae14ef661a1bbe/android/samples/sample-hello-triangle/src/main/java/com/google/android/filament/hellotriangle/MainActivity.kt)) provided in the filament repo. Just skim through, there is lot more than we discussed.
> look into the `onCreate()`, `setupFilament()`, `setupView()` and `onDestroy()` methods.
> 
> Also look into the [Choreographer.FrameCallback](https://developer.android.com/reference/android/view/Choreographer.FrameCallback) Android api.  

### SwapChain
> A SwapChain represents an Operating System's native renderable surface. Typically it's a native window or a view. Because a SwapChain is initialized from a native object, it is given to filament as an Object, which must be of the proper type for each platform filament is running on.
For Android the native window object must be of type [Surface](https://developer.android.com/reference/android/view/Surface).

Create swapchain using the filament Engine instance

`swapChain = engine.createSwapChain(surface, uiHelper.swapChainFlags)`

`uiHelper.swapChainFlags` provides the flags about configurations set on the UiHelper instance(android only helper to manage surface view).

> info: Swapchain can be created and destroyed with help of uiHelper render callbacks.
>
> info: Swapchain is later passed to renderer to init a new frame.

### UiHelper (Android specific)
> UiHelper is a simple class that can manage either a SurfaceView, TextureView, or a SurfaceHolder so it can be used to render into with Filament.

It provides callbacks(UiHelper.RenderCallback) on native window changes, on detachment and on resize. After attaching surface view, must detach on destroy. Also check if view is ready to render.

> Now look into the `FrameCallback` and `SurfaceCallback` inner classes in [HelloTriangle sample](https://github.com/google/filament/blob/ca3b84197441e351ef490d61cbae14ef661a1bbe/android/samples/sample-hello-triangle/src/main/java/com/google/android/filament/hellotriangle/MainActivity.kt#L287)

### DisplayHelper (Android specific)
> DisplayHelper is here to help managing a Display, for instance being notified when its resolution or refresh rate changes.

Attach the display and assosiated renderer, to receive display config changes.

### Vertex Buffer
> Holds a set of buffers that define the geometry of a Renderable. 
>  The geometry of the Renderable itself is defined by a set of vertex attributes such as position, color, normals, tangents, etc...
>
> There is no need to have a 1-to-1 mapping between attributes and buffer. A buffer can hold the data of several attributes -- attributes are then referred as being "interleaved". _ie: empty space between different attributes_
>
> The buffers themselves are GPU resources, therefore mutating their data can be relatively slow. For this reason, it is best to separate the constant data from the dynamic data into multiple buffers.
>
> It is possible, and even encouraged, to use a single vertex buffer for several Renderables. 

Vertex 'Buffer' is an array of memory in the GPU, that holds the geometry information(such as position, color, normals, tangents, etc...) about the shape we need to draw.

* First create a new ByteBuffer `vertexData` using [`ByteBuffer.allocate`](https://developer.android.com/reference/java/nio/ByteBuffer#allocate(int)), which allocates space for the buffer's content. 
  > The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a backing array, and its array offset will be zero.
* Then create a vertexBuffer using filament's `VertexBuffer.Builder()` 
  > `VertexBuffer.Builder()` have following methods
  > * `bufferCount(int bufferCount)` : Defines how many buffers will be created in this vertex buffer set.
  > * `vertexCount(int vertexCount)` : Size of each buffer in this set, expressed in in number of vertices.
  > * attribute(VertexBuffer.VertexAttribute attribute, int bufferIndex, VertexBuffer.AttributeType attributeType, int byteOffset, int byteStride) : Sets up an attribute for this vertex buffer set.
  > * `normalized(VertexBuffer.VertexAttribute attribute)` : Sets whether a given attribute should be normalized.
  > *  	`build(Engine engine)` : Creates the VertexBuffer object and returns a pointer to it.
* Copy the vertexBuffer to vertexData and pass to filament engine using `vertexBuffer.setBufferAt(engine, bufferIndex, vertexData)` 
  > * `setBufferAt(Engine engine, int bufferIndex, java.nio.Buffer buffer, int destOffsetInBytes, int count)` : Asynchronously copy-initializes a region of the specified buffer from the given buffer data.

### Index Buffer
> A buffer containing vertex indices into a VertexBuffer. Indices can be 16 or 32 bit. The buffer itself is a GPU resource, therefore mutating the data can be relatively slow. Typically these buffers are constant. It is possible, and even encouraged, to use a single index buffer for several Renderables.

* First create a new ByteBuffer `indexData` using [`ByteBuffer.allocate`](https://developer.android.com/reference/java/nio/ByteBuffer#allocate(int)), which allocates space for the buffer's content. 
  > The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a backing array, and its array offset will be zero.
* Create indexBuffer using `IndexBuffer.Builder()`
  > `IndexBuffer.Builder()` have following methods
  > * `indexCount(int indexCount)` : Size of the index buffer in elements.
  > * `bufferType(IndexBuffer.Builder.IndexType indexType)` : Type of the index buffer, 16-bit or 32-bit.
  > * `build(Engine engine)` : Creates and returns the IndexBuffer object.
* Copy the indexBuffer to the indexData and pass to filament engine using `indexBuffer.setBuffer(engine, indexData)`.
  > `setBuffer(Engine engine, java.nio.Buffer buffer, _int destOffsetInBytes, int count, java.lang.Object handler, java.lang.Runnable callback_)` 	
Asynchronously copy-initializes a region of this IndexBuffer from the data provided.

> Now look into the `createMesh()` method in [HelloTriangle sample](https://github.com/google/filament/blob/ca3b84197441e351ef490d61cbae14ef661a1bbe/android/samples/sample-hello-triangle/src/main/java/com/google/android/filament/hellotriangle/MainActivity.kt#L162)







